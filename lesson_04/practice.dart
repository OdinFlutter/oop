// –£–†–û–ö 4: –ü—Ä–∞–∫—Ç–∏–∫–∞ ‚Äî –ü–æ–ª—ñ–º–æ—Ä—Ñ—ñ–∑–º
// –í–∏–∫–æ–Ω—É–π—Ç–µ –∑–∞–≤–¥–∞–Ω–Ω—è –ø–æ—Å—Ç—É–ø–æ–≤–æ, —Ä–æ–∑–∫–æ–º–µ–Ω—Ç–æ–≤—É—é—á–∏ taskX() –ø–æ —á–µ—Ä–∑—ñ
// –ó–∞–ø—É—Å–∫: dart practice.dart

void main() {
  print('–ü—Ä–∞–∫—Ç–∏–∫–∞ ‚Äî –£—Ä–æ–∫ 4: –ü–æ–ª—ñ–º–æ—Ä—Ñ—ñ–∑–º\n');

  // –†–æ–∑–∫–æ–º–µ–Ω—Ç—É–π—Ç–µ –ø–æ—Ç—Ä—ñ–±–Ω–µ –∑–∞–≤–¥–∞–Ω–Ω—è –¥–ª—è –≤–∏–∫–æ–Ω–∞–Ω–Ω—è
  // task1();
  // task2();
  // task3();
  // task4();
  // task5();

  print('–í—Å—ñ –∑–∞–≤–¥–∞–Ω–Ω—è –≤–∏–∫–æ–Ω–∞–Ω–æ! –ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ solutions.dart –¥–ª—è –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è.');
}

// =============================================================================
// –ó–ê–í–î–ê–ù–ù–Ø 1: –†—ñ–∑–Ω—ñ —Ç–∏–ø–∏ —à–∏–Ω –∑ –ø–æ–ª—ñ–º–æ—Ä—Ñ–Ω–æ—é –ø–æ–≤–µ–¥—ñ–Ω–∫–æ—é
// =============================================================================

void task1() {
  print('–ó–ê–í–î–ê–ù–ù–Ø 1: –†—ñ–∑–Ω—ñ —Ç–∏–ø–∏ —à–∏–Ω –∑ –ø–æ–ª—ñ–º–æ—Ä—Ñ–Ω–æ—é –ø–æ–≤–µ–¥—ñ–Ω–∫–æ—é');
  print('=' * 30);

  /*
  üîé –©–æ —Ç–∞–∫–µ –ø–æ–ª—ñ–º–æ—Ä—Ñ—ñ–∑–º?
  –ü–æ–ª—ñ–º–æ—Ä—Ñ—ñ–∑–º ‚Äî —Ü–µ –∑–¥–∞—Ç–Ω—ñ—Å—Ç—å –æ–±'—î–∫—Ç—ñ–≤ —Ä—ñ–∑–Ω–∏—Ö –∫–ª–∞—Å—ñ–≤ —Ä–µ–∞–≥—É–≤–∞—Ç–∏ –Ω–∞ –æ–¥–Ω–∞–∫–æ–≤—ñ –º–µ—Ç–æ–¥–∏ –ø–æ-—Ä—ñ–∑–Ω–æ–º—É. –ù–∞–ø—Ä–∏–∫–ª–∞–¥, —Ä—ñ–∑–Ω—ñ —Ç–∏–ø–∏ —à–∏–Ω –º–∞—é—Ç—å —Ä—ñ–∑–Ω—É –ø–æ–≤–µ–¥—ñ–Ω–∫—É, –∞–ª–µ –≤—Å—ñ –º–∞—é—Ç—å –æ–¥–Ω–∞–∫–æ–≤–∏–π —ñ–Ω—Ç–µ—Ä—Ñ–µ–π—Å.

  üèÅ –ù–∞–≤—ñ—â–æ —Ü–µ –ø–æ—Ç—Ä—ñ–±–Ω–æ?
  –¶–µ –¥–æ–∑–≤–æ–ª—è—î –ø–∏—Å–∞—Ç–∏ —É–Ω—ñ–≤–µ—Ä—Å–∞–ª—å–Ω–∏–π –∫–æ–¥, —è–∫–∏–π –ø—Ä–∞—Ü—é—î –∑ —Ä—ñ–∑–Ω–∏–º–∏ –æ–±'—î–∫—Ç–∞–º–∏ —á–µ—Ä–µ–∑ —Å–ø—ñ–ª—å–Ω–∏–π —ñ–Ω—Ç–µ—Ä—Ñ–µ–π—Å.

  ‚úÖ –©–æ —Ç—Ä–µ–±–∞ –∑—Ä–æ–±–∏—Ç–∏:
  1. –°—Ç–≤–æ—Ä–∏ –∞–±—Å—Ç—Ä–∞–∫—Ç–Ω–∏–π –∫–ª–∞—Å Tire –∑ –≤–ª–∞—Å—Ç–∏–≤–æ—Å—Ç—è–º–∏:
     - compound (String): —Ç–∏–ø —Å—É–º—ñ—à—ñ
     - durability (int): –∫—ñ–ª—å–∫—ñ—Å—Ç—å –∫—ñ–ª –¥–æ –∑–Ω–æ—Å—É
     - grip (double): —Ä—ñ–≤–µ–Ω—å –∑—á–µ–ø–ª–µ–Ω–Ω—è 0.0-1.0

  2. –î–æ–¥–∞–π –∞–±—Å—Ç—Ä–∞–∫—Ç–Ω—ñ –º–µ—Ç–æ–¥–∏:
     - performanceDuringRace(): –ø–æ–∫–∞–∑—É—î –ø–æ–≤–µ–¥—ñ–Ω–∫—É —à–∏–Ω–∏ –ø—ñ–¥ —á–∞—Å –≥–æ–Ω–∫–∏
     - degradeOverTime(): –ø–æ–∫–∞–∑—É—î, —è–∫ —à–∏–Ω–∞ –∑–Ω–æ—à—É—î—Ç—å—Å—è

  3. –°—Ç–≤–æ—Ä–∏ –¥–æ—á—ñ—Ä–Ω—ñ –∫–ª–∞—Å–∏:
     - SoftTire: –í–∏—Å–æ–∫–µ –∑—á–µ–ø–ª–µ–Ω–Ω—è (0.9), –Ω–∏–∑—å–∫–∞ –¥–æ–≤–≥–æ–≤—ñ—á–Ω—ñ—Å—Ç—å (15 –∫—ñ–ª)
     - MediumTire: –ë–∞–ª–∞–Ω—Å (0.7), —Å–µ—Ä–µ–¥–Ω—è –¥–æ–≤–≥–æ–≤—ñ—á–Ω—ñ—Å—Ç—å (25 –∫—ñ–ª)
     - HardTire: –ú–µ–Ω—à–µ –∑—á–µ–ø–ª–µ–Ω–Ω—è (0.5), –≤–∏—Å–æ–∫–∞ –¥–æ–≤–≥–æ–≤—ñ—á–Ω—ñ—Å—Ç—å (40 –∫—ñ–ª)
     - WetTire: –î–ª—è –¥–æ—â—É (0.8), —Å–µ—Ä–µ–¥–Ω—è –¥–æ–≤–≥–æ–≤—ñ—á–Ω—ñ—Å—Ç—å (20 –∫—ñ–ª)

  4. –ü–µ—Ä–µ–≤–∏–∑–Ω–∞—á –∫–æ–∂–µ–Ω –º–µ—Ç–æ–¥ –¥–ª—è –∫–æ–∂–Ω–æ–≥–æ —Ç–∏–ø—É —à–∏–Ω–∏.

  üß© –ü–æ—è—Å–Ω–µ–Ω–Ω—è:
  - abstract class ‚Äî —Ü–µ –∫–ª–∞—Å, —è–∫–∏–π –Ω–µ –º–æ–∂–Ω–∞ —Å—Ç–≤–æ—Ä–∏—Ç–∏ –Ω–∞–ø—Ä—è–º—É, —Ç—ñ–ª—å–∫–∏ —á–µ—Ä–µ–∑ –Ω–∞—Å–ª—ñ–¥—É–≤–∞–Ω–Ω—è
  - @override ‚Äî –ø–µ—Ä–µ–≤–∏–∑–Ω–∞—á–∞—î–º–æ –º–µ—Ç–æ–¥ –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ—ó —à–∏–Ω–∏

  üí° –ü—ñ–¥–∫–∞–∑–∫–∞:
  –î–ª—è —Å–ø–∏—Å–∫—É —à–∏–Ω –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π List<Tire> —ñ —Ü–∏–∫–ª for (var tire in tireSet) { ... }

  üî® –ü–æ–∫—Ä–æ–∫–æ–≤–∏–π –ø—Ä–∏–∫–ª–∞–¥:

    abstract class Tire {
      String compound;
      int durability;
      double grip;

      Tire(this.compound, this.durability, this.grip);

      void performanceDuringRace();
      void degradeOverTime();
    }

    class SoftTire extends Tire {
      SoftTire() : super('Soft', 15, 0.9);

      @override
      void performanceDuringRace() {
        print('Soft: –î—É–∂–µ —à–≤–∏–¥–∫–∞, –∞–ª–µ —à–≤–∏–¥–∫–æ –∑–Ω–æ—à—É—î—Ç—å—Å—è.');
      }

      @override
      void degradeOverTime() {
        print('Soft: –ó—á–µ–ø–ª–µ–Ω–Ω—è –ø–∞–¥–∞—î –ø—ñ—Å–ª—è 10 –∫—ñ–ª.');
      }
    }

    class MediumTire extends Tire {
      MediumTire() : super('Medium', 25, 0.7);

      @override
      void performanceDuringRace() {
        print('Medium: –ë–∞–ª–∞–Ω—Å —à–≤–∏–¥–∫–æ—Å—Ç—ñ —Ç–∞ –¥–æ–≤–≥–æ–≤—ñ—á–Ω–æ—Å—Ç—ñ.');
      }

      @override
      void degradeOverTime() {
        print('Medium: –ó—á–µ–ø–ª–µ–Ω–Ω—è —Å—Ç–∞–±—ñ–ª—å–Ω–µ –¥–æ 20 –∫—ñ–ª.');
      }
    }

    class HardTire extends Tire {
      HardTire() : super('Hard', 40, 0.5);

      @override
      void performanceDuringRace() {
        print('Hard: –ü–æ–≤—ñ–ª—å–Ω—ñ—à–∞, –∞–ª–µ –¥—É–∂–µ –¥–æ–≤–≥–æ–≤—ñ—á–Ω–∞.');
      }

      @override
      void degradeOverTime() {
        print('Hard: –ó—á–µ–ø–ª–µ–Ω–Ω—è –ø–∞–¥–∞—î –ø—ñ—Å–ª—è 30 –∫—ñ–ª.');
      }
    }

    class WetTire extends Tire {
      WetTire() : super('Wet', 20, 0.8);

      @override
      void performanceDuringRace() {
        print('Wet: –í—ñ–¥–º—ñ–Ω–Ω–∞ –¥–ª—è –¥–æ—â—É, –≥–∞—Ä–Ω–µ –∑—á–µ–ø–ª–µ–Ω–Ω—è –Ω–∞ –º–æ–∫—Ä–æ–º—É.');
      }

      @override
      void degradeOverTime() {
        print('Wet: –ó—á–µ–ø–ª–µ–Ω–Ω—è –ø–∞–¥–∞—î, —è–∫—â–æ —Ç—Ä–∞—Å–∞ –ø—ñ–¥—Å–∏—Ö–∞—î.');
      }
    }

    void main() {
      List<Tire> tireSet = [
        SoftTire(),
        MediumTire(),
        HardTire(),
        WetTire(),
      ];

      for (var tire in tireSet) {
        tire.performanceDuringRace();
        tire.degradeOverTime();
        print('');
      }
    }

  -----------------------------------------------------------------------------
  –Ø–∫—â–æ –Ω–µ –∑—Ä–æ–∑—É–º—ñ–ª–æ ‚Äî —Å–∫–æ–ø—ñ—é–π —Ü–µ–π –ø—Ä–∏–∫–ª–∞–¥ —É solutions.dart —ñ –∑–º—ñ–Ω—é–π –¥–∞–Ω—ñ!
  */

  // –¢—É—Ç —Å—Ç–≤–æ—Ä–∏ —Å–≤–æ—ó –∫–ª–∞—Å–∏ —Ç–∞ –ø—Ä–æ—Ç–µ—Å—Ç—É–π —ó—Ö

  print('');
}

// =============================================================================
// TASK 2: Racing flags with different meanings
// =============================================================================

void task2() {
  print('TASK 2: Racing flags polymorphism');
  print('=' * 35);

  /*
  TASK:
  Create an abstract RacingFlag class with:
  - color (String): flag color
  - meaning (String): what the flag means
  
  Add abstract method:
  - displayToDrivers(): shows flag message to drivers
  
  Create these flag types:
  - GreenFlag: Race start/restart, "RACE IS ON!"
  - YellowFlag: Caution, "SLOW DOWN - DANGER AHEAD"
  - RedFlag: Stop race, "STOP IMMEDIATELY - SAFETY ISSUE"
  - ChequeredFlag: Race finish, "RACE FINISHED - CONGRATULATIONS!"
  - BlueFlag: Let faster car pass, "MOVE ASIDE - FASTER CAR APPROACHING"
  
  Each flag should have unique driver instructions.
  Create a race marshal system that can display any flag.
  */

  // TODO: Create RacingFlag abstract class and flag types

  // TODO: Create race marshal and test flags
  // List<RacingFlag> raceFlags = [
  //   GreenFlag(),
  //   YellowFlag(),
  //   BlueFlag(),
  //   ChequeredFlag(),
  // ];

  // print('Race Marshal communicating with drivers:\n');
  // for (var flag in raceFlags) {
  //   flag.displayToDrivers();
  //   print('');
  // }

  print('');
}

// =============================================================================
// TASK 3: Engine types with different characteristics
// =============================================================================

void task3() {
  print('TASK 3: Engine polymorphism');
  print('=' * 28);

  /*
  TASK:
  Create an abstract Engine class with:
  - horsepower (int): engine power
  - fuelType (String): type of fuel
  - engineType (String): engine type name
  
  Add abstract methods:
  - startEngine(): engine startup behavior
  - accelerate(): acceleration characteristics
  - engineSound(): what sound the engine makes
  
  Create these engine types:
  - V6TurboEngine: F1 style, 1000hp, hybrid fuel
  - V8Engine: NASCAR style, 750hp, gasoline
  - ElectricEngine: Formula E, 400hp, battery
  - V12Engine: Classic F1, 900hp, gasoline
  
  Each engine should have unique startup, acceleration, and sound.
  Test by starting different engines and showing their characteristics.
  */

  // TODO: Create Engine abstract class and engine types

  // TODO: Test different engines
  // List<Engine> engines = [
  //   V6TurboEngine(),
  //   V8Engine(),
  //   ElectricEngine(),
  //   V12Engine(),
  // ];

  // print('Testing different engines:\n');
  // for (var engine in engines) {
  //   engine.startEngine();
  //   engine.accelerate();
  //   engine.engineSound();
  //   print('HP: ${engine.horsepower}, Fuel: ${engine.fuelType}');
  //   print('~' * 25);
  // }

  print('');
}

// =============================================================================
// TASK 4: Race track surfaces with different grip levels
// =============================================================================

void task4() {
  print('TASK 4: Track surface polymorphism');
  print('=' * 35);

  /*
  TASK:
  Create an abstract TrackSurface class with:
  - surfaceType (String): type of surface
  - gripLevel (double): grip coefficient 0.0-1.0
  - temperature (int): surface temperature in Celsius
  
  Add abstract methods:
  - affectCar(String carName): how surface affects the car
  - recommendedSpeed(): suggested speed for this surface
  - tireDegradation(): how fast tires wear on this surface
  
  Create these surfaces:
  - AsphaltSurface: High grip (0.9), normal tire wear
  - ConcreteSurface: Medium grip (0.7), high tire wear  
  - WetAsphalt: Low grip (0.4), low tire wear, requires caution
  - IceSurface: Very low grip (0.1), very low tire wear, extreme caution
  
  Test with a car driving on different surfaces.
  */

  // TODO: Create TrackSurface abstract class and surface types

  // TODO: Test car on different surfaces
  // String carName = 'Ferrari SF-75';
  // List<TrackSurface> surfaces = [
  //   AsphaltSurface(),
  //   ConcreteSurface(),
  //   WetAsphalt(),
  //   IceSurface(),
  // ];

  // for (var surface in surfaces) {
  //   print('Surface: ${surface.surfaceType}');
  //   surface.affectCar(carName);
  //   surface.recommendedSpeed();
  //   surface.tireDegradation();
  //   print('');
  // }

  print('');
}

// =============================================================================
// TASK 5: Complex task - Race commentator system
// =============================================================================

void task5() {
  print('TASK 5: Race commentator polymorphism');
  print('=' * 38);

  /*
  TASK:
  Create an abstract RaceCommentator class with:
  - name (String): commentator name
  - experience (int): years of experience
  - specialty (String): what they're known for
  
  Add abstract methods:
  - commentOnOvertake(String driver1, String driver2): overtake commentary
  - commentOnCrash(String driver): crash commentary  
  - commentOnVictory(String winner): victory commentary
  - getExcitement(): excitement level for different events
  
  Create these commentator types:
  - ExcitedCommentator: High energy, lots of enthusiasm
  - TechnicalCommentator: Detailed analysis, calm delivery
  - EmotionalCommentator: Emotional reactions, dramatic flair
  - ComedyCommentator: Funny remarks, light-hearted tone
  
  Create a race broadcast system that uses different commentators
  for different race events. Test with various race scenarios.
  */

  // TODO: Create RaceCommentator abstract class and commentator types

  // TODO: Create race broadcast system and test scenarios
  // List<RaceCommentator> commentators = [
  //   ExcitedCommentator('David Croft', 15, 'High Energy'),
  //   TechnicalCommentator('Martin Brundle', 25, 'Technical Analysis'),
  //   EmotionalCommentator('Murray Walker', 35, 'Emotional Drama'),
  //   ComedyCommentator('James Hunt', 20, 'Witty Remarks'),
  // ];

  // // Test different race events
  // print('RACE BROADCAST SYSTEM\n');
  //
  // for (var commentator in commentators) {
  //   print('${commentator.name} commenting:');
  //   commentator.commentOnOvertake('Hamilton', 'Verstappen');
  //   commentator.commentOnVictory('Leclerc');
  //   print('Excitement level: ${commentator.getExcitement()}');
  //   print('~' * 30);
  // }

  print('');
}

// =============================================================================
// HELPFUL NOTES
// =============================================================================

/*
POLYMORPHISM TIPS:

1. ABSTRACT CLASSES:
   - Use 'abstract' keyword
   - Can have concrete and abstract methods
   - Cannot be instantiated directly
   - Child classes MUST implement abstract methods

2. METHOD OVERRIDING:
   - Use @override annotation
   - Child method replaces parent method
   - Same method name, different implementation

3. POLYMORPHIC BEHAVIOR:
   - Same method call, different behaviors
   - Dart determines which method to call at runtime
   - Works with lists of parent type containing child objects

4. DESIGN PATTERNS:
   - Define common interface in parent
   - Implement specific behavior in children  
   - Code works with parent type, gets child behavior

5. BENEFITS:
   - Flexible and extensible code
   - Easy to add new types
   - Clean interfaces
   - Real-world modeling

EXAMPLE PATTERN:
```dart
abstract class Parent {
  void commonMethod(); // Abstract - must implement
  
  void sharedMethod() {  // Concrete - can override
    print('Default behavior');
  }
}

class Child extends Parent {
  @override
  void commonMethod() {
    print('Child-specific behavior');
  }
}
```
*/
